<!DOCTYPE html>
<html>
<head>
  <title>Cardacci</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="A blog about becoming a software developer by Marc Cardacci">
  <link rel="stylesheet" type="text/css" href="../CSS/blog-stylesheet.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
 <link href='https://fonts.googleapis.com/css?family=Oswald|Exo:300' rel='stylesheet' type='text/css'>
</head>

<body>
  <header>
    <h1 class="title">Marc Cardacci <br> <span>(A blog about becoming a software developer.)</h1>
      <div class="top-nav">
        <ul>
          <a href="../index.html">
            <li>
                <i class="fa fa-home fa-2x"></i>
                <br>
                Home
            </li>
          </a>
          <a href="about.html">
            <li>
              <i class="fa fa-street-view fa-2x"></i>
                <br>
                About
            </li>
          </a>
          <a href="archive.html">
            <li>
              <i class="fa fa-newspaper-o fa-2x"></i>
                <br>
                Archive
              </li>
          </a>
          <a href="#">
              <li>
                <i class="fa fa-search fa-2x"></i>
                  <br>
                  Search
              </li>
          </a>
        </ul>
      </div>
  </header>
<div class="horizontal-line">
    <div class="blog-content">
        <h4>3/6/15</h4>
        <h1>Blocks, Procs and Lambdas</h1>
          <p>
            Before learning what these data structures are capable of, it's important to know how they are classified. Blocks, Procs and Lambda's are what are referred to in computer science as closures. A closure is a data structure that stores a function. Inside the function is it's own environment, like a tiny universe. Closures remember the values of the variables that were in it's environment when the function was created. After it's been created, it is then able to access the variables stored inside. The most common example of closures are blocs.<br> Example block:
          </p>
          <pre>
            <code>
              array <span style="color:orange;">=</span> [<span style="color: blue">1</span>, <span style="color: blue">2</span>, <span style="color: blue">3</span>, <span style="color: blue">4</span>]
              array.map { |<span style="color:blue;">num</span>| p num<span style="color:orange;">**</span>2 }
                    <span style="color:grey;">#  ^block is here</span>
               <span style="color:grey;"># => [1, 4, 9, 16]</span>
            </code>
          </pre>
            <ul>
            <li>
              &#8674; Here we've used #map on a local variable 'array' containing an array of integers 1-4.
            </li>
            <br>
            <li>&#8674;
              The code block interacts with a variable inside the {}, called 'num'.
            </li>
            <br>
            <li>&#8674;
              'num' represents every index in 'array' being squared, one-by-one.
            </li>
            <br>
            <li>&#8674;
              The result is an array with each index squared.
            </li>
          </ul>
          <p>
            An often touted falsity about Ruby is that everything is an Object. Well, prepare for your mind to be blown. Blocks are in fact NOT OBJECTS! Take for instance the above example; The Array is an object, it's called on by the map method which is an object. But the block itself is simply part of the syntax of a method call. There is no Block class in the Ruby library. It's purely a syntactic construct. So technically blocks aren't considered closures until they're put in methods. Once blocks are named they can be passed around and exploited at will.
          </p>
        <h1>Procs</h1>
          <p>
            Procs are objects that store chunks of code which you can create, store, pass as method arguments and execute at will with the 'call' method. Lets create a proc. Example:
          </p>
          <pre>
            <code>
              p <span style="color:orange;">=</span> <span style="color:purple;">Proc</span>.<span style="color:orange;">new</span> { p <span style="color:#5bdf5d;">"Inside a proc"</span> }
              pr <span style="color:orange;">=</span> proc { p <span style="color:#5bdf5d;">"Inside a proc"</span> }

              p
              <span style="color:blue;">=> "Inside a proc"</span>
              pr
              <span style="color:blue;">=> "Inside a proc"</span>
            </code>
          </pre>
          <p>
            Both of these ways instantiate a proc. When you instantiate them, you must include a code block inside {}. Everything else that happens to them is a variation or addition to this syntax.
          </p>
          <p>
            Now that we know that procs are objects, that gives us the freedom to assign them to variables, put them inside arrays, make them method arguments and come up with some mind-bending code. Next we'll write a method for the Array class. Here's an example:
          </p>
          <pre>
            <code>
              <span style="color:orange;">class</span> <span style="color:DeepSkyBlue;">Array</span>
                <span style="color:orange;">def</span> <span style="color:DeepSkyBlue;">iterate!</span>(<span style="color:orange;">&</span>code)
                  <span style="color:blue;">self</span>.each_with_index <span style="color:orange;">do</span> |<span style="color:blue;">num</span>, <span style="color:blue;">index</span>|
                    <span style="color:blue;">self</span>[index] <span style="color:orange;">=</span> code.call(num)
                  <span style="color:orange;">end</span>
                <span style="color:orange;">end</span>
              <span style="color:orange;">end</span>

              array <span style="color:orange;">=</span> [<span style="color:blue;">1</span>,<span style="color:blue;">2</span>,<span style="color:blue;">3</span>,<span style="color:blue;">4</span>]

              array.iterate! { |<span style="color:blue;">n</span>| n <span style="color:orange;">*</span> <span style="color:blue;">3</span> }

              p array
              <span style="color:blue;">=> [3,6,9,12]</span>
            </code>
          </pre>
        <p>
          <b>Note</b>: This is pretty uncommon to do this in Ruby as the language has plenty of useful methods already built in but it's a good exercise.
        </p>
        <ol>
          <li>
            It's easiest to start at the '.iterate' code block where we see that we are iterating over an array and multiplying each index by 3.
          </li>
          <li>
            When the 'iterate!' is called in the environment and ran on an Array object, the code block is treated as a proc.
          </li>
          <li>
            If we take a look at the 'iterate!' method's argument you'll see an '&' symbol which is a call 'to_proc'.
          </li>
          <li>
            Inside the method, the code is called and all the numbers multiplied by three (in step 1) are permanently set to the indices: self[index] = code.call(num)
          </li>
        </ul>
        <p>
          Procs differ from other types closures in the way that they handle arguments. They don't care if they get the correct number of arguments when they get called. Example:
        </p>
        <pre>
            <code>
              p <span style="color:orange;">=</span> proc { |<span style="color:blue;">n</span>| puts n }

              p.call
              <span style="color:blue;">=> nil</span>
              p.(<span style="color:blue;">1</span>,<span style="color:blue;">2</span>,<span style="color:blue;">3</span>)
              <span style="color:blue;">=> 1</span>
            </code>
        </pre>
        <p>
          If no arguments get called when the proc expects one argument, it returns nil. If there are more arguments than the expected it returns the first one. Procs are not fussy with their argument list.
        </p>
      <h1>Lambdas</h1>
        <p>
          The syntax of a lambda is very similar to that of a Proc. In fact, lambdas <b>are</b> procs. Meaning that the object that is returned from a lambda is part of the Proc class. They're are just a fussier sibling of the proc. Example:
        </p>
        <pre>
          <code>
            lam <span style="color:orange;">=</span> lambda { puts <span style="color:#5bdf5d;">"A lambda!"</span> }
            lam.call
            <span style="color:blue;">=> "A lambda!"</span>
          </code>
        </pre>
        <p>
          Ruby implicitly creates procs. So if you've grabbed a code block pointed at a proc, Ruby thinks it's a normal proc. If you want to use a lambda you have to CREATE a lambda explicitly.
        </p>
        <pre>
          <code>
            <span style="color:orange;">def</span> <span style="color:DeepSkyBlue;">iterate!</span>(<span style="color:orange;">&</span>code)
          </code>
        </pre>
        <p>
          The return keyword is also different between lambda's and procs.
        </p>
        <pre>
          <code>
            <span style="color:orange;">def</span> <span style="color:DeepSkyBlue;">proc_return</span>
              proc { <span style="color:orange;">return</span> <span style="color:#5bdf5d;">"Proc.new"</span>}.call
              <span style="color:orange;">return</span> <span style="color:#5bdf5d;">"this won't get printed"</span>
            <span style="color:orange;">end</span>

            <span style="color:orange;">def</span> <span style="color:DeepSkyBlue;">lambda_return</span>
              lambda { <span style="color:orange;">return</span> <span style="color:#5bdf5d;">"lambda"</span> }.call
              <span style="color:orange;">return</span> "This does get printed"
            <span style="color:orange;">end</span>

            puts proc_return
            <span style="color:blue;">=> Proc.new</span>
            puts lambda_return
            <span style="color:blue;">=> "This does get printed"</span>
          </code>
        </pre>
        <p>
          A return inside a Proc triggers a return from the code block itself. Inside the lambda however, it exits from the lambda block and in this case returns a string.
        </p>
        <p>
          Unlike the proc, lambdas do in fact care about how many arguments they are given. If you pass them the wrong number like this:
        </p>
        <pre>
          <code>
            lam <span style="color:orange;">=</span> lam { |<span style="color:blue;">n</span>| puts n }

            p.call
            <span style="color:blue;">=> ArgumentError wrong number of arguments (0 for 1)</span>
            p.(<span style="color:blue;">1</span>,<span style="color:blue;">2</span>,<span style="color:blue;">3</span>)
            <span style="color:blue;">=> ArgumentError wrong number of arguments (3 for 1)</span>
          </code>
        </pre>
        <p>
          The take away:
        </p>
        <ul>
          <li>&#8674;
            Blocks are chunks of code used in methods. They AREN'T objects and are basically a syntactical construct.
          </li><br>
          <li>&#8674;
            Procs are similar in appearance to blocks but are actually objects. They can be inserted into methods, arguments and can be stored for later use. They aren't fussy about their argument list.
          </li><br>
          <li>&#8674;
            Lambdas are basically procs but they are fussy about their arguments. They must be explicitly created because the Ruby default is Proc. They also make a slightly different use of the 'return' keyword.
          </li>
        </ul>
        <h2>References:</h2>
        <p>
          <a href="http://www.reactive.io/tips/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/">Understanding Blocks, Procs and Lambdas</a><br>
          <a href="http://www.reactive.io/tips/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/">Closures - A Simple Explanation</a><br>
          <a href="http://www.amazon.com/The-Well-Grounded-Rubyist-David-Black/dp/1933988657">The Well Grounded Rubyist by David A. Black</a>
        </p>
    </div>
  <div class="horizontal-line">
    <footer>
      <ul class="footer-icons">
        <a href="https://github.com/mcardacci/">
              <li class="bottom-icon">
                <i class="fa fa-github fa-2x"></i>
              </li>
          </a>
        <a href="https://twitter.com/MarcCardacci">
              <li class="bottom-icon">
                <i class="fa fa-twitter fa-2x"></i>
              </li>
          </a>
        <a href="https://www.facebook.com/profile.php?id=100008146878953">
              <li class="bottom-icon">
                <i class="fa fa-facebook fa-2x"></i>
              </li>
          </a>
        <a href="https://www.linkedin.com/profile/view?id=383416184&trk=nav_responsive_tab_profile">
              <li class="bottom-icon">
                <i class="fa fa-linkedin-square fa-2x"></i>
              </li>
          </a>
      </ul>
      <p>Copyright Â© Marc Cardacci 2015</p>
    </footer>
  </div>
</body>
</html>
