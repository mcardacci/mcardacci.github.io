<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
    <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
    <link rel="stylesheet" href="../fonts/font-awesome/css/font-awesome.min.css">
    <script src="../JavaScript/site.js"></script>
    <script src="../JavaScript/blog.js"></script>
    <title>Sorting Algorithms | A. Burgess</title>
  </head>
  <body onload="fadeIn('entire-blog');"> <!-- onload for fade of blog elements opacity -->
    <div class="grid grid-pad">
      <div class="col-2-3 header">
        <header>
          <h1><span>aceburgess</span> .github.io</h1>
        </header>
      </div>

      <div class="col-1-1 mobile_break">
      </div>

      <div class="col-1-3 header twitter">
        <a href="https://twitter.com/aceburgess">
          <i class="fa fa-twitter fa-lg"></i>
        </a>
      </div>

      <div class="col-1-1 desktop_break">
        <!--Keeps Content and sidebar below Header-->
      </div>

      <div class="col-1-3 sidebar">
        <nav onclick="">
          <div class="module back">
           <a href="../index.html">
            <i class="fa fa-chevron-left fa-lg"></i></a><z></z>
          </div>

          <div class="module nav">
            <ul id="navigation">
              <li>
                <a href="../index.html">
                  <i class="fa fa-chevron-left fa-4x"></i>
                </a>
              </li>
            </ul>
          </div>
        </nav>
      </div>

      <div class="col-1-1 mobile_break">
      </div>

      <div class="col-2-3 content">
        <main id="entire-blog">
          <div class="blog-header">
            <h1>Sorting Algorithms</h1>
            <h2>Bubble Sort, Merge Sort, Quick Sort, even Bogo Sort. First three written in Ruby.</h2>
            <h4>March 24 2015</h4>
          </div>

          <section class="blog-post">
            <p>
              Today I wanted to go over something that was a ton of fun learning about. That's right sorting arrays baby. I actually really loved researching the different algorithms and shed tears of laughter looking at my new favorite sorting algorithm the bogosort.
            <br>
            <br>
              So I actually worte my own Ruby code for the Bubble sort, Merge sort, and Quick sort algorithms. Let's start with:
            </p>
            <br>
            <br>
            <h3>Bubble Sort</h3>
            <br>
            <p>
              Bubble Sort goes through the array one element at a time and compares it with the element after. If the first element is greater than the second element they are swapped. This process continues through the entire array until a whole pass goes by where not a single element is moved. This is part of the reason why bubble sort is not seen as a great algorithm when working with medium to larger datasets. It's average performance is O(nÂ²) and best case is O(n) which is great but only really happens if the array is fully sorted to begin with (aka pointless). You can see in my code that I'm setting my sorting variable to true so that I know when the array is still being sorted. If even one element is swapped the variable sorting is set back to true. Only once an entire pass goes by that not a single array[n] is greater than array[n+1] do I let that sorting = false and break free from the loop.
            </p>

<pre>
<code>

  shuffled_array = [3,5,7,1,4,6,10,2,8,9]


  def bubble_sort array
    length = array.length
    sorting = true
    while sorting
      sorting = false
      (length-1).times do |n|
        if array[n] > array [n+1]
          array[n], array[n+1] = array[n+1], array[n]
          sorting = true
        end
      end
    end
    return array
  end


  p "Bubble Sort: #{bubble_sort shuffled_array}"

  => Bubble Sort: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

</code>
</pre>
            <br>
            <br>
            <h3>Merge Sort</h3>
            <br>
            <p>
              Merge sort works very differently from Bubble sort. I wrote this code using recursion and even had to write out the recursive process on paper so I could understand what's going on at each level. Merge sort works by splitting the array into two halves and then splitting those sub-arrays into two halves and doing that all the way down till at least one array from the left-right split have no elements inside. No sorting happens until that process is done. Then on the way back up each sub-array is sorted by their first element being compared to the first element of the other sub-array until at least one of those arrays has no more elements and then that temporary sorted array is merged with the other sub-array and technically the empty sub-array whether it be the left or right. This keeps happening until we finally reach our initial call of merge_sort where we combine the two sorted halves in the final run through the merge method. This method will go again through the first element of each array left and right and compare them and if the first left element is less than the first right element the first element is moved to the sorted array. Otherwise the first right element is moved to the sorted array. This keeps going until either the left or right array is empty. Then the final sub-arrays are concatenated to the sorted array and we get our solution. Best, Worst, and Average case scenarios the performance of Merge sort is O(n*log(n)). Decent for medium and larger datasets.
            </p>

<pre>
<code>

  shuffled_array = [3,5,7,1,4,6,10,2,8,9]


  def merge_sort(array)
    size = array.length
    return array if size <= 1
    middle = size / 2
    left, right = array.partition.with_index { |n, index| index < middle }
    merge merge_sort(left), merge_sort(right)
  end

  def merge(left, right)
    sorted = []
    until left.count == 0 || right.count == 0
      left.first < right.first ? sorted << left.shift : sorted << right.shift
    end
    sorted + left + right
  end


  p "Merge Sort: #{merge_sort shuffled_array}"

  => Merge Sort: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

</code>
</pre>
            <br>
            <br>
            <h3>Quick Sort</h3>
            <br>
            <p>
              Quick sort is the final sorting algorithm I'm going to go over today. It's somewhat similar to the Merge Sort and has the same Big-O notation time-complexity, however, instead of the left and right sections being split up into even halves they are actually randomly split by one number from the array which then takes every element less than that value (called the pivot) and transfers it to the left array and all the elements greater than the pivot and transfers those to the right array. This goes on recursively until each sub-array is sorted and joined by concatenation going all the way back up to the first level in the stack where the final two arrays are joined to make one perfectly sorted array. Code for this algorithm is below:
            </p>

<pre>
<code>

  shuffled_array = [3,5,7,1,4,6,10,2,8,9]


  def quick_sort array
    return array if array.count <= 1
    pivot = array.shuffle.pop
    left, right = array.partition {|n| n < pivot}
    quick_sort(left) + quick_sort(right)
  end

  p "Quick Sort: #{quick_sort shuffled_array}"

  => Quick Sort: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

</code>
</pre>

            <br>
            <br>
            <p>
              I mentioned my new favorite sorting algorithm being bogosort. To give you an example of what bogosort is let's pretend you have 30 cards with the numbers 1 through 30 on them. Take those cards and throw them off of a bridge. Go get those cards and line them up. Are they in order? No? Take those cards this time and throw them out of your car window. Turn around pick them up and line em up. In order yet? No? Well what are you waiting for...pick those bad boys up and make it rain on the sidewalk. Third times a charm. And now it's time for you to think about how long you wanna continue like this. It's a dark existence. Funny thing about bogosort is it has a best case scenario of 0(n) which is excellent and a worst case scenario of an unbounded number of tries.
            </p>
          </section>
        </main>
      </div>

      <div class="col-1-1 mobile_break">
      </div>

      <div class="col-1-1">
        <footer id="footerJS"></footer>
      </div>

    </div>
  </body>
</html>