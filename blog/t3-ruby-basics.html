<!DOCTYPE html>
<head>
  <title>Back 2 The Basics</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
  <link href='http://fonts.googleapis.com/css?family=Cutive+Mono' rel='stylesheet' type='text/css'>
</head>

<main>
  <div class="blog-header">
    <h1>Back 2 The Basics</h1>
    <h2>Ruby Basics To Be More Exact</h2>
    <h4>February 21, 2105</h4>
  </div>

  <section class="blog-post">
    <p>
      Let's discuss Ruby basics. "The Well Grounded Rubyist" by David A. Black has helped take my Ruby understanding up a notch, and it was set to a very low notch before. I usually gravitate to tutorials when it comes to learning these sorts of things, but this book really taught me a lot. I'm going to go over what I've learned so far from some sections in the book. I still have more than half of the book to go through, but writing this down will help me solidify what I've learned so far, and in turn I hope it helps you.
    </p>

    <p>
      <h3>Boolean States</h3>
      One thing you can count on is that every object in Ruby has a Boolean value of either 'true' or 'false'. And every single expression will evaluate to an object that will fall in one of those two Boolean categories. That's something I suspected, but wasn't entirely convinced. Also, 'nil' evaluates to the object 'false'.
      <blockquote class="ruby">
        if "pigs can fly"<br>
        &nbsp;&nbsp;puts "yeah we all know pigs fly"<br>
        else<br>
        &nbsp;&nbsp;puts "no, pigs can't fly, dumbA$$"<br>
        end<br>
        <br>
        => "yeah we all know pigs fly"
      </blockquote>
    </p>
    <p>
      "pigs can fly" is true in Ruby no matter what you've heard.
    </p>

    <p>
      <h3>Comparisons</h3>
      The 'spaceship operator' <=> is a very useful comparison device.
      If the left-hand object being compared is greater than the right-hand object the expression will return 1. If the right-hand object is greater than the left-hand object the value returned will be -1.<br>
      If both objects are equal the returned value will be 0.<br>
      Here's a short example:
      <blockquote class="ruby">
        4 <=> 3<br>
        => 1<br>

        4 <=> 300<br>
        => -1<br>

        434 <=> 434<br>
        => 0
      </blockquote>
    </p>

    <p>
      <h3>Strings</h3>
      One really cool thing about Ruby is how many ways you can do the same thing. This doesn't change when creating strings. There are certainly multiple ways you can create a String object in Ruby. The strangest and most interesting way in my mind is %q which makes a single quoted string and %Q which makes a double quoted string. The most terrifying thing is that the delimiter can be (almost) anything as long as you open and close the string with the same delimiter. Example:
      <blockquote class="ruby">
        %q{hello world, how are you?}<br>
        => "hello world, how are you?"<br>
        <br>
        %q*hi world, please answer me!*<br>
        => "hi world, please answer me!"<br>
        <br>
        %Q-ok world, whatever-<br>
        => "ok world, whatever"
      </blockquote>
    </p>

    <p>
      Even though the first two strings returned with double-quotes...When they are evaluated they have single-quotes same as if you were to create a string with literal single-quotes:
      <blockquote class="ruby">
        'hello'<br>
        => "hello"
      </blockquote>
    </p>

    <p>
      <h3>Numerical Objects</h3>
      Interesting fact...The arithmetic operators that you would use to perform mathematical calculations are actually methods like any other method in Ruby and can be written that way too. Example:

      <blockquote class="ruby">
        4 + 3<br>
        => 7<br>
        <br>
        4.+(3)<br>
        => 7
        4.*(3)<br>
        => 12<br>
      </blockquote>
      It doesn't look as clean to write it the second and third way, but still might be important to understand that they are methods, but with the special ability to be written differently than other methods.
    </p>

    <p>
      <h3>Arrays and Hashes</h3>
      I wrote a whole <a href="t3-arrays-hashes.html">blog post</a> on my comparison between Arrays and Hashes, but I'll touch on one thing I learned after writing that blog post. I already knew about iterating over arrays and identifying current index number by using the method each_with_index, but it works with hashes too (in a different way). The same method can be used to identify the key=>value pair index which does have a numerical value. This numerical value represents the index of the pair not the individual key or value.
    </p>

    <p>
      <h3>Arrays</h3>
      When creating a new Array you can pass some arguments to the array and even include a block of code. Examples:
      <blockquote class="ruby">
        Array.new(5, "hello")<br>
        => ["hello", "hello", "hello", "hello", "hello"]<br>
        <br>
        number = 6<br>
        Array.new(5) {number -= 1}<br>
        => [5, 4, 3, 2, 1]
      </blockquote>
      These are very helpful ways to add content to an array at the time of initializing. The first method will create the same object however many times you indicate in the first argument. The second method creates separate objects and runs the code block however many times you indicate in the argument, (5 times in this example) and places the entire code block evaluated into each slot of the array consecutively.
    </p>

    <p>
      <h3>Hashes</h4>
      Hashes seem to be a lot more involved to create than Arrays, and yet there is a method for creating hashes that's kinda array-like. Example:
      <blockquote class="ruby">
        new_hash = Hash["key", "value", "street", "halsey st", "city", "brooklyn", "phone", "212-123-REAL"]<br>
        <br>
        => {"key"=>"value", "street"=>"halsey st", "city"=>"brooklyn", "phone"=>"212-123-REAL"}
      </blockquote>
      If you start with Hash[] and make sure the 'arguments', which look a lot like creating an array are an even number in total then you can create a Hash in a way that I feel is personally much quicker than using the 'key => value, key => value' technique. However, every technique has it's place. This interesting technique probably won't be as clear that it's a hash to everyone that looks at your code.
    </p>

    <p>
      <h3>Ranges</h3>
      Ranges are fun to make. Right? You can easily create an array with the numbers 1 to 100 like this: (1..100).to_a<br>
      That will create an array with 100 values: index 0 equaling 1 and index 99 equaling 100.
      The two main things that can cause confusion with ranges are whether or not they are inclusive or exclusive. For some reason I remembered that fairly quickly, but I don't really have a technique I could share:<br>
      1..100 will end on 100<br>
      1...100 will end on 99<br>
      I guess it just seems more inclusive with two dots than three.
    </p>
    <p>
      I'm learning more and more Ruby each day and hope to finish this amazing book by David A. Black.
      Please get yourselves a copy. I couldn't wait for shipping so I bought the digital version.
      You can buy both physical and e-book versions here:<br>
      <a href="http://www.manning.com/black3/">The Well Grounded Rubyist (updated for Ruby 2.1)</a>
    </p>
  </section>
</main>